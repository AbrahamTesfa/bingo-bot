// ----- Imports -----
const express = require("express");
const http = require("http");
const WebSocket = require("ws");
const path = require("path");
const { v4: uuid } = require("uuid");

// ----- Lowdb Setup -----
const { Low } = require("lowdb");
const { JSONFile } = require("lowdb/node");

// Pass default data when creating Low instance
const adapter = new JSONFile("bingo.json");
const db = new Low(adapter, { rooms: [], players: [], requests: [] });

// ----- Initialize DB -----
async function initDB() {
  await db.read(); // Load existing data or create new
  // Seed rooms if empty
  if (db.data.rooms.length === 0) {
    db.data.rooms = [
      { roomId: "room_10", cost: 10, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_20", cost: 20, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_50", cost: 50, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_100", cost: 100, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
    ];
  }

  // Seed fake users if empty
  if (db.data.players.length === 0) {
    db.data.players = [
      { userId: "u1", username: "Phone_1", balance: 1000, wins: 0, gamesPlayed: 0 },
      { userId: "u2", username: "Phone_2", balance: 800, wins: 0, gamesPlayed: 0 },
      { userId: "u3", username: "Phone_3", balance: 500, wins: 0, gamesPlayed: 0 },
    ];
  }

  await db.write();
}

// ----- Express + WebSocket -----
const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// ----- In-memory rooms -----
const rooms = {};
const players = new Map(); // ws -> player info

async function loadRooms() {
  await db.read();
  db.data.rooms.forEach(r => {
    rooms[r.roomId] = {
      players: [],
      gameStarted: !!r.gameStarted,
      numbersCalled: r.numbersCalled || [],
      cost: r.cost,
      jackpot: r.jackpot,
      gameInterval: null,
      countdown: null,
      countdownTime: r.currentCountdown || 60,
      currentCountdown: r.currentCountdown || 60,
    };
  });
}

// ----- Utilities -----
function calcJackpot(room) {
  return Math.floor(room.players.length * room.cost * 0.9);
}

function updateRoomStatus() {
  const status = {};
  for (const id in rooms) {
    const room = rooms[id];
    status[id] = {
      players: room.players.length,
      jackpot: calcJackpot(room),
      cost: room.cost,
      gameStarted: room.gameStarted,
    };
  }

  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify({ type: "room_status_update", room_status: status }));
    }
  });
}

function checkBingo(card, numbersCalled) {
  const BINGO = ["B", "I", "N", "G", "O"];
  const isLineMarked = line => line.every(num => num === 0 || numbersCalled.includes(num));

  // Rows
  for (let i = 0; i < 5; i++) {
    if (isLineMarked(BINGO.map(letter => card[letter][i]))) return true;
  }

  // Columns
  for (const letter of BINGO) {
    if (isLineMarked(card[letter])) return true;
  }

  // Diagonals
  const diag1 = BINGO.map((l, i) => card[l][i]);
  const diag2 = BINGO.map((l, i) => card[BINGO[4 - i]][i]);
  return isLineMarked(diag1) || isLineMarked(diag2);
}

// ----- Game Loop -----
function startGame(roomId) {
  const room = rooms[roomId];
  if (!room || room.gameStarted) return;

  room.gameStarted = true;
  room.numbersCalled = [];
  const availableNumbers = Array.from({ length: 75 }, (_, i) => i + 1);

  room.players.forEach(p => {
    p.send(JSON.stringify({ type: "game_started", cards: p.cards, numbersCalled: [] }));
  });

  room.gameInterval = setInterval(() => {
    if (!availableNumbers.length || !room.players.length) {
      clearInterval(room.gameInterval);
      room.gameStarted = false;
      room.players.forEach(p => p.send(JSON.stringify({ type: "game_end" })));
      return;
    }

    const num = availableNumbers.splice(Math.floor(Math.random() * availableNumbers.length), 1)[0];
    room.numbersCalled.push(num);
    room.players.forEach(p => {
      p.send(JSON.stringify({ type: "number_called", number: num, calledNumbers: room.numbersCalled }));
    });
  }, 3000);
}

// ----- WebSocket -----
wss.on("connection", ws => {
  ws.id = uuid();
  console.log(`Client connected: ${ws.id}`);

  ws.on("message", async msg => {
    let data;
    try { data = JSON.parse(msg); } catch { return; }

    switch (data.type) {
      case "get_player_data": {
        await db.read();
        const user = db.data.players.find(u => u.userId === data.userId);
        if (!user) return;
        ws.userId = data.userId;
        ws.send(JSON.stringify({ type: "player_data", ...user }));
        break;
      }

      case "join_room": {
        const { roomId, cards, userId } = data;
        const room = rooms[roomId];
        if (!room) return;

        await db.read();
        const user = db.data.players.find(u => u.userId === userId);
        if (!user || user.balance < room.cost) {
          ws.send(JSON.stringify({ type: "error", message: "Insufficient funds" }));
          return;
        }

        user.balance -= room.cost;
        await db.        ws.roomId = roomId;
        ws.cards = cards;
        ws.userId = userId;

        room.players.push(ws);
players.set(ws, { userId, cards, roomId });

// SEND CARDS IMMEDIATELY
ws.send(JSON.stringify({
  type: "player_cards",
  cards: ws.cards
}));

ws.send(JSON.stringify({ type: "room_joined", playerId: ws.id, roomId, cards: ws.cards, balance: user.balance }));
        updateRoomStatus();

        // Countdown before game starts
        if (!room.gameStarted && !room.countdown) {
          let countdownTime = room.countdownTime;
          room.currentCountdown = countdownTime;

          room.countdown = setInterval(() => {
            room.players.forEach(p => {
              p.send(JSON.stringify({
                type: "number_called",
                number: countdownTime,
                calledNumbers: room.numbersCalled,
                countdown: true
              }));
            });

            countdownTime--;
            room.currentCountdown = countdownTime;

            if (countdownTime < 0) {
              clearInterval(room.countdown);
              room.countdown = null;
              startGame(roomId);
            }
          }, 1000);
        } else if (room.countdown) {
          ws.send(JSON.stringify({
            type: "number_called",
            number: room.currentCountdown,
            calledNumbers: room.numbersCalled,
            countdown: true
          }));
        }

        break;
      }

      case "claim_bingo": {
        const room = rooms[data.roomId];
        if (!room) return;
        const player = room.players.find(p => p.id === data.playerId);
        if (!player) return;

        const valid = player.cards.some(card => checkBingo(card, room.numbersCalled));
        if (valid) {
          const jackpot = calcJackpot(room);
          await db.read();
          const user = db.data.players.find(u => u.userId === player.userId);
          if (user) {
            user.balance += jackpot;
            user.wins++;
            await db.write();
          }

          room.players.forEach(p => p.send(JSON.stringify({ type: "bingo_win", winnerId: player.id })));
          clearInterval(room.gameInterval);
          room.gameStarted = false;
          room.players.forEach(p => p.send(JSON.stringify({ type: "game_end" })));
          room.numbersCalled = [];
          updateRoomStatus();
        } else {
          ws.send(JSON.stringify({ type: "invalid_bingo" }));
        }
        break;
      }

      case "request_deposit":
      case "request_withdrawal": {
        const req = {
          id: uuid(),
          userId: data.userId,
          type: data.type === "request_deposit" ? "deposit" : "withdrawal",
          amount: data.amount,
          status: "pending"
        };
        await db.read();
        db.data.requests.push(req);
        await db.write();
        ws.send(JSON.stringify({ type: "request_status_update", ...req }));
        break;
      }

      case "get_admin_requests": {
        await db.read();
        ws.send(JSON.stringify({ type: "requests_data", requests: db.data.requests }));
        break;
      }

      case "approve_request":
      case "reject_request": {
        await db.read();
        const req = db.data.requests.find(r => r.id === data.requestId);
        if (!req) return;

        req.status = data.type === "approve_request" ? "approved" : "rejected";
        await db.write();

        if (req.status === "approved") {
          const user = db.data.players.find(u => u.userId === req.userId);
          if (user) {
            if (req.type === "deposit") user.balance += req.amount;
            else if (req.type === "withdrawal") user.balance -= req.amount;
            await db.write();
          }
        }

        ws.send(JSON.stringify({ type: "request_action_success" }));
        break;
      }
    }
  });

  ws.on("close", () => {
    const player = players.get(ws);
    if (player && player.roomId) {
      const room = rooms[player.roomId];
      room.players = room.players.filter(p => p.id !==ws.id);
      updateRoomStatus();
    }
    players.delete(ws);
  });
});

// ----- Serve frontend -----
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "index.html"));
});

// ----- Start server -----
(async () => {
  await initDB();   // Initialize DB with defaults
  await loadRooms(); // Load rooms into memory

  const PORT = process.env.PORT || 3000;
  server.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
  });
})();

