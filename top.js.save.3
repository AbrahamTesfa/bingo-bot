// ----- Imports -----
const express = require("express");
const http = require("http");
const WebSocket = require("ws");
const path = require("path");
const { v4: uuid } = require("uuid");
const { Low } = require("lowdb");
const { JSONFile } = require("lowdb/node");

// ----- Lowdb Setup -----
const adapter = new JSONFile("bingo.json");
const db = new Low(adapter, { rooms: [], players: [], requests: [] });

// ----- Initialize DB -----
async function initDB() {
  await db.read();

  if (!db.data.rooms || db.data.rooms.length === 0) {
    db.data.rooms = [
      { roomId: "room_10", cost: 10, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_20", cost: 20, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_50", cost: 50, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_100", cost: 100, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
    ];
  }

  if (!db.data.players) db.data.players = [];

  await db.write();
}

// ----- Express + WebSocket -----
const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// ----- In-memory rooms -----
const rooms = {};
const players = new Map(); // ws -> player info

// ----- Load rooms into memory -----
async function loadRooms() {
  await db.read();
  db.data.rooms.forEach(r => {
    rooms[r.roomId] = {
      players: [],
      cards: generateRoomCards(),
      gameStarted: !!r.gameStarted,
      numbersCalled: r.numbersCalled || [],
      cost: r.cost,
      jackpot: r.jackpot,
      gameInterval: null,
      countdown: null,
      countdownTime: r.currentCountdown || 60,
      currentCountdown: r.currentCountdown || 60,
    };
  });
}

// ----- Card Sending -----

function sendRoomCards(ws, roomId, phase = "selection") {
  const room = rooms[roomId];
  if (!room) return;

  if (phase === "selection") {
    // Only send card IDs for selection phase
    ws.send(JSON.stringify({
      type: "show_cards",
      phase: "selection",
      roomId,
      allCards: room.cards.map(c => ({
        id: c.id,
        takenBy: c.takenBy
      }))
    }));
  } else if (phase === "game") {
    // Send the player's actual cards (with full 5x5 numbers)
    ws.send(JSON.stringify({
      type: "show_cards",
      phase: "game",
      roomId,
      cards: ws.cards // ws.cards contains full formatted 5x5 grids
    }));
  }
}

function formatCardForClient(card) {
  // card.data is flat 25 elements (see generateBingoCard)
  // Convert values to numeric when possible; ensure free cell becomes 0.
  const sliceToNums = (arr) => arr.map(n => (n === "FREE" || n === null || n === undefined) ? 0 : Number(n));

  const B = sliceToNums(card.data.slice(0, 5));
  const I = sliceToNums(card.data.slice(5, 10));
  const N = sliceToNums(card.data.slice(10, 15));
  const G = sliceToNums(card.data.slice(15, 20));
  const O = sliceToNums(card.data.slice(20, 25));

  return { B, I, N, G, O }; // client expects this shape
}
// ----- Utilities -----
function calcJackpot(room) {
  return Math.floor(room.players.length * room.cost * 0.9);
}

function generateBingoCard() {
  const card = [];
  const columns = { B: [1, 15], I: [16, 30], N: [31, 45], G: [46, 60], O: [61, 75] };

  for (const [_, [min, max]] of Object.entries(columns)) {
    const nums = [];
    while (nums.length < 5) {
      const n = Math.floor(Math.random() * (max - min + 1)) + min;
      if (!nums.includes(n)) nums.push(n);
    }
    card.push(...nums);
  }

  // center free cell should be numeric 0 so checkBingo/extractWinningPattern work
  card[12] = 0;
  return card; // flat 25-element array: B[0..4], I[0..4], N[0..4], G[0..4], O[0..4]
}
function generateRoomCards() {
  return Array.from({ length: 100 }, (_, i) => ({ id: i + 1, data: generateBingoCard(), takenBy: null }));
}

function updateRoomStatus() {
  const status = {};
  for (const id in rooms) {
    const room = rooms[id];
    status[id] = {
      players: room.players.length,
      jackpot: calcJackpot(room),
      cost: room.cost,
      gameStarted: room.gameStarted,
      calledNumbersCount: room.numbersCalled.length,
    };
  }
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify({ type: "room_status_update", room_status: status }));
    }
  });
}

// ----- Broadcast helper -----
function broadcastToRoom(roomId, message) {
  const room = rooms[roomId];
  if (!room) return;

  room.players.forEach(ws => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  });
}

function checkBingo(card, numbersCalled) {
  const BINGO = ["B", "I", "N", "G", "O"];
  const isLineMarked = line => line.every(num => num === 0 || numbersCalled.includes(num));

  // Rows
  for (let i = 0; i < 5; i++) if (isLineMarked(BINGO.map(l => card[l][i]))) return true;
  // Columns
  for (const l of BINGO) if (isLineMarked(card[l])) return true;
  // Diagonals
  const diag1 = BINGO.map((l, i) => card[l][i]);
  const diag2 = BINGO.map((l, i) => card[BINGO[4 - i]][i]);
  return isLineMarked(diag1) || isLineMarked(diag2);
}

function extractWinningPattern(card, numbersCalled) {
  const BINGO = ["B", "I", "N", "G", "O"];

  for (let row = 0; row < 5; row++) {
    const rowNums = BINGO.map(l => card[l][row]);
    if (rowNums.every(n => n === 0 || numbersCalled.includes(n))) return rowNums.map((num, col) => [row, col]);
  }

  for (let col = 0; col < 5; col++) {
    const colNums = BINGO.map(l => card[l][col]);
    if (colNums.every(n => n === 0 || numbersCalled.includes(n))) return colNums.map((num, row) => [row, col]);
  }

  const diag1 = BINGO.map((l, i) => card[l][i]);
  if (diag1.every(n => n === 0 || numbersCalled.includes(n))) return diag1.map((num, i) => [i, i]);

  const diag2 = BINGO.map((l, i) => card[BINGO[4 - i]][i]);
  if (diag2.every(n => n === 0 || numbersCalled.includes(n))) return diag2.map((num, i) => [i, 4 - i]);

  return null;
}

// ----- Game Loop -----
function startGame(roomId) {
  const room = rooms[roomId];
  if (!room || room.gameStarted) return;

  room.gameStarted = true;
  room.numbersCalled = [];

  // Ensure every player has real bingo cards
  room.players.forEach(ws => {
    if (!ws.cards || ws.cards.length === 0) {
      const raw = generateBingoCard();
      const cardObj = { id: `gen_${uuid()}`, data: raw, takenBy: ws.userId };
      const formatted = formatCardForClient(cardObj);
      ws.cards = [formatted];
    }
    sendRoomCards(ws, roomId, "game"); // send the actual cards
  });

  const availableNumbers = Array.from({ length: 75 }, (_, i) => i + 1);

  // Call numbers every 3 seconds
  room.gameInterval = setInterval(() => {
    if (!availableNumbers.length || !room.players.length) {
      clearInterval(room.gameInterval);
      room.gameStarted = false;
      room.players.forEach(p => p.send(JSON.stringify({ type: "game_end" })));
      return;
    }

    const num = availableNumbers.splice(Math.floor(Math.random() * availableNumbers.length), 1)[0];
    room.numbersCalled.push(num);

    // Broadcast called number to all players
    room.players.forEach(p => {
      if (p.readyState === WebSocket.OPEN) {
        p.send(JSON.stringify({
          type: "number_called",
          number: num,
          calledNumbers: room.numbersCalled,
          countdown: false
        }));
      }
    });
  }, 3000);
}
  
function startRoomCountdown(roomId) {
  const room = rooms[roomId];
  if (!room) return;

  let countdownTime = room.countdownTime;
  room.currentCountdown = countdownTime;

  room.countdown = setInterval(() => {
    room.players.forEach(p => {
      if (p.readyState === WebSocket.OPEN) {
        p.send(JSON.stringify({
          type: "number_called",
          number: countdownTime,
          calledNumbers: room.numbersCalled,
          countdown: true
        }));
      }
    });

    countdownTime--;
    room.currentCountdown = countdownTime;

    if (countdownTime < 0) {
      clearInterval(room.countdown);
      room.countdown = null;
      startGame(roomId);
    }
  }, 1000);
}

// ----- WebSocket -----
wss.on("connection", ws => {
  ws.id = uuid();
  console.log(`Client connected: ${ws.id}`);

  ws.on("message", async msg => {
    let data;
    try { data = JSON.parse(msg); } catch { return; }

    switch (data.type) {
      case "get_player_data": {
        await db.read();
        let user = db.data.players.find(u => u.userId === data.userId);
        if (!user) {
          user = { userId: data.userId, username: `Player_${data.userId}`, balance: 1000, wins: 0, gamesPlayed: 0 };
          db.data.players.push(user);
          await db.write();
        }
        ws.userId = data.userId;
        ws.send(JSON.stringify({ type: "player_data", ...user }));
        break;
      }

      case "join_room": {
        const { roomId, userId } = data;
        const room = rooms[roomId];
        if (!room) return;

        await db.read();
        const user = db.data.players.find(u => u.userId === userId);
        if (!user || user.balance < room.cost) {
          ws.send(JSON.stringify({ type: "error", message: "Insufficient funds" }));
          return;
        }

        user.balance -= room.cost;
        await db.write();

        ws.roomId = roomId;
        ws.userId = userId;
        ws.cards = [];

        room.players.push(ws);
        players.set(ws, { userId, roomId, cards: ws.cards });

        ws.send(JSON.stringify({
          type: "room_joined",
          playerId: ws.id,
          roomId,
          balance: user.balance
   

      case "get_ca     sendRoomCards(ws, data.roomId, "selection");
        break;

      case "select_card": {
        const room = rooms[data.roomId];
        if (!room) break;

        const card = room.cards.find(c => c.id === data.cardId);
        if (!card) {
          ws.send(JSON.stringify({ type: "card_rejected", reason: "Card not found" }));
          break;
        }

        if (card.takenBy && card.takenBy !== data.userId) {
          ws.send(JSON.stringify({ type: "card_rejected", reason: "Already taken" }));
          break;
        }

        const userCards = room.cards.filter(c => c.takenBy === data.userId);
        if (userCards.length >= 4) {
          ws.send(JSON.stringify({ type: "card_rejected", reason: "Max 4 cards reached" }));
          break;
        }

        card.takenBy = data.userId;

        if (!ws.cards) ws.cards = [];
        const formatted = formatCardForClient(card);
        ws.cards.push(formatted);

        ws.send(JSON.stringify({
          type: "card_selected",
          roomId: data.roomId,
          cardId: card.id,
          userId: data.userId
        }));

        room.players.forEach(p => {
          if (p.readyState === WebSocket.OPEN) {
            p.send(JSON.stringify({
              type: "card_taken",
              roomId: data.roomId,
              cardId: card.id,
              userId: data.userId
            }));
          }
        });

        updateRoomStatus();
        break;
      }

      case "claim_bingo": {
        const room = rooms[data.roomId];
        if (!room) return;

        const player = room.players.find(p => p.id === data.playerId);
        if (!player) return;

        let winningCard = null;
        let winningPattern = null;

        for (const card of player.cards) {
          if (checkBingo(card, room.numbersCalled)) {
            winningCard = card;
            winningPattern = extractWinningPattern(card, room.numbersCalled);
            break;
          }
        }

        if (winningCard) {
          const jackpot = calcJackpot(room);
          await db.read();
          const user = db.data.players.find(u => u.userId === player.userId);
          if (user) {
            user.balance += jackpot;
            user.wins++;
            await db.write();
          }

          room.players.forEach(p => p.send(JSON.stringify({
            type: "bingo_win",
            winnerId: player.id,
            winnerCard,
            winningPattern
          })));

          clearInterval(room.gameInterval);
          room.gameStarted = false;
          room.players.forEach(p => p.send(JSON.stringify({ type: "game_end" })));
          room.numbersCalled = [];
          updateRoomStatus();
        } else {
          ws.send(JSON.stringify({ type: "invalid_bingo" }));
        }

        break;
      }

      case "start_game": {
  const room = rooms[data.roomId];
  if (room && !room.gameStarted && !room.countdown) {
    startRoomCountdown(data.roomId);
  }
  break;
}     
      case "request_deposit":
      case "request_withdrawal": {
        const req = {
          id: uuid(),
          userId: data.userId,
          type: data.type === "request_deposit" ? "deposit" : "withdrawal",
          amount: data.amount,
          status: "pending"
        };
        await db.read();
        db.data.requests.push(req);
        await db.write();
        ws.send(JSON.stringify({ type: "request_status_update", ...req }));
        break;
      }

      case "get_admin_requests": {
        await db.read();
        ws.send(JSON.stringify({ type: "requests_data", requests: db.data.requests }));
        break;
      }

      case "approve_request":
      case "reject_request": {
        await db.read();
        const req = db.data.requests.find(r => r.id === data.requestId);
        if (!req) return;
        req.status = data.type === "approve_request" ? "approved" : "rejected";
        if (req.status === "approved") {
          const user = db.data.players.find(u => u.userId === req.userId);
          if (user) {
            if (req.type === "deposit") user.balance += req.amount;
            else if (req.type === "withdrawal") user.balance -= req.amount;
            await db.write();
          }
        }
        await db.write();
        ws.send(JSON.stringify({ type: "request_action_success" }));
        break;
      }
    }
  });

  ws.on("close", () => {
    const player = players.get(ws);
    if (player && player.roomId) {
      const room = rooms[player.roomId];
      room.players = room.players.filter(p => p.id !== ws.id);
      updateRoomStatus();
    }
    players.delete(ws);
  });
});

// ----- Serve frontend -----
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "index.html"));
});

// ----- Start server -----
(async () => {
  await initDB();
  await loadRooms();
  const PORT = process.env.PORT || 3000;
  server.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));
})();
