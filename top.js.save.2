// ----- Imports -----
const express = require("express");
const http = require("http");
const WebSocket = require("ws");
const path = require("path");
const { v4: uuid } = require("uuid");
const { Low } = require("lowdb");
const { JSONFile } = require("lowdb/node");

// ----- Lowdb Setup -----
const adapter = new JSONFile("bingo.json");
const db = new Low(adapter, { rooms: [], players: [], requests: [] });

// ----- Initialize DB -----
async function initDB() {
  await db.read();

  // Initialize rooms if empty
  if (!db.data.rooms || db.data.rooms.length === 0) {
    db.data.rooms = [
      { roomId: "room_10", cost: 10, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_20", cost: 20, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_50", cost: 50, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
      { roomId: "room_100", cost: 100, jackpot: 0, numbersCalled: [], gameStarted: 0, currentCountdown: 60 },
    ];
  }

  // Ensure players array exists
  if (!db.data.players) db.data.players = [];

  await db.write();
}

// ----- Express + WebSocket -----
const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// ----- In-memory rooms -----
const rooms = {};
const players = new Map(); // ws -> player info

// ----- Load rooms into memory -----
async function loadRooms() {
  await db.read();
  db.data.rooms.forEach(r => {
    rooms[r.roomId] = {
      players: [],
      cards: generateRoomCards(),
      gameStarted: !!r.gameStarted,
      numbersCalled: r.numbersCalled || [],
      cost: r.cost,
      jackpot: r.jackpot,
      gameInterval: null,
      countdown: null,
      countdownTime: r.currentCountdown || 60,
      currentCountdown: r.currentCountdown || 60,
    };
  });
}

// ----- Utilities -----
function calcJackpot(room) {
  return Math.floor(room.players.length * room.cost * 0.9);
}

function generateBingoCard() {
  const card = [];
  const columns = { B: [1, 15], I: [16, 30], N: [31, 45], G: [46, 60], O: [61, 75] };
  for (const [_, [min, max]] of Object.entries(columns)) {
    const nums = [];
    while (nums.length < 5) {
      const n = Math.floor(Math.random() * (max - min + 1)) + min;
      if (!nums.includes(n)) nums.push(n);
    }
    card.push(...nums);
  }
  card[12] = "FREE"; // Free space
  return card;
}

function generateRoomCards() {
  return Array.from({ length: 100 }, (_, i) => ({ id: i + 1, data: generateBingoCard(), takenBy: null }));
}

function updateRoomStatus() {
  const status = {};
  for (const id in rooms) {
    const room = rooms[id];
    status[id] = {
      players: room.players.length,
      jackpot: calcJackpot(room),
      cost: room.cost,
      gameStarted: room.gameStarted,
      calledNumbersCount: room.numbersCalled.length,
    };
  }
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify({ type: "room_status_update", room_status: status }));
    }
  });
}

function checkBingo(card, numbersCalled) {
  const BINGO = ["B", "I", "N", "G", "O"];
  const isLineMarked = line => line.every(num => num === 0 || numbersCalled.includes(num));

  // Rows
  for (let i = 0; i < 5; i++) if (isLineMarked(BINGO.map(l => card[l][i]))) return true;
  // Columns
  for (const l of BINGO) if (isLineMarked(card[l])) return true;
  // Diagonals
  const diag1 = BINGO.map((l, i) => card[l][i]);
  const diag2 = BINGO.map((l, i) => card[BINGO[4 - i]][i]);
  return isLineMarked(diag1) || isLineMarked(diag2);
}

function extractWinningPattern(card, numbersCalled) {
  const BINGO = ["B", "I", "N", "G", "O"];
  for (let row = 0; row < 5; row++) {
    const rowNums = BINGO.map(l => card[l][row]);
    if (rowNums.every(n => n === 0 || numbersCalled.includes(n))) return rowNums.map((_, col) => [row, col]);
  }
  for (let col = 0; col < 5; col++) {
    const colNums = BINGO.map(l => card[l][col]);
    if (colNums.every(n => n === 0 || numbersCalled.includes(n))) return colNums.map((_, row) => [row, col]);
  }
  const diag1 = BINGO.map((l, i) => card[l][i]);
  if (diag1.every(n => n === 0 || numbersCalled.includes(n))) return diag1.map((_, i) => [i, i]);
  const diag2 = BINGO.map((l, i) => card[BINGO[4 - i]][i]);
  if (diag2.every(n => n === 0 || numbersCalled.includes(n))) return diag2.map((_, i) => [i, 4 - i]);
  return null;
}

// ----- Game Loop -----
function startGame(roomId) {
  const room = rooms[roomId];
  if (!room || room.gameStarted) return;

  room.gameStarted = true;
  room.numbersCalled = [];
  const availableNumbers = Array.from({ length: 75 }, (_, i) => i + 1);

  room.players.forEach(p => p.send(JSON.stringify({ type: "game_started", cards: p.cards, numbersCalled: [] })));

  room.gameInterval = setInterval(() => {
    if (!availableNumbers.length || !room.players.length) {
      clearInterval(room.gameInterval);
      room.gameStarted = false;
      room.players.forEach(p => p.send(JSON.stringify({ type: "game_end" })));
      return;
    }
    const num = availableNumbers.splice(Math.floor(Math.random() * availableNumbers.length), 1)[0];
    room.numbersCalled.push(num);
    room.players.forEach(p => p.send(JSON.stringify({ type: "number_called", number: num, calledNumbers: room.numbersCalled })));
  }, 3000);
}

// ----- WebSocket -----
wss.on("connection", ws => {
  ws.id = uuid();
  console.log(`Client connected: ${ws.id}`);

  ws.on("message", async msg => {
    let data;
    try { data = JSON.parse(msg); } catch { return; }

    switch (data.type) {
      // ----- Get or register player -----
      case "get_player_data": {
        await db.read();
        let user = db.data.players.find(u => u.userId === data.userId);
        if (!user) {
          // Dynamic creation of new player
          user = { userId: data.userId, username: `Player_${data.userId}`, balance: 1000, wins: 0, gamesPlayed: 0 };
          db.data.players.push(user);
          await db.write();
        }
        ws.userId = data.userId;
        ws.send(JSON.stringify({ type: "player_data", ...user }));
        break;
      }

      // ----- Join room -----
      case "join_room": {
        const { roomId, cards, userId } = data;
        const room = rooms[roomId];
        if (!room) return;

        await db.read();
        const user = db.data.players.find(u => u.userId === userId);
        if (!user || user.balance < room.cost) {
          ws.send(JSON.stringify({ type: "error", message: "Insufficient funds" }));
          return;
        }

        user.balance -= room.cost;
        await db.write();

        ws.roomId = roomId;
        ws.cards = cards;
        ws.userId = userId;
        room.players.push(ws);
        players.set(ws, { userId, cards, roomId });

        ws.send(JSON.stringify({ type: "room_joined", playerId: ws.id, roomId, cards, balance: user.balance }));
        ws.send(JSON.stringify({ type: "show_cards", cards: ws.cards }));
        updateRoomStatus();

        // Countdown
        if (!room.gameStarted && !room.countdown) {
          let countdownTime = room.countdownTime;
          room.currentCountdown = countdownTime;

          room.countdown = setInterval(() => {
            room.players.forEach(p => p.send(JSON.stringify({ type: "number_called", number: countdownTime, calledNumbers: room.numbersCalled, countdown: true })));
            countdownTime--;
            room.currentCountdown = countdownTime;
            if (countdownTime < 0) {
              clearInterval(room.countdown);
              room.countdown = null;
              startGame(roomId);
            }
          }, 1000);
        } else if (room.countdown) {
          ws.send(JSON.stringify({ type: "number_called", number: room.currentCountdown, calledNumbers: room.numbersCalled, countdown: true }));
        }
        break;
      }


// ----- Get cards for selection -----
case "get_cards": {
    const room = rooms[data.roomId];
    if (!room) break;

    // If no cards yet, generate 1â€“100
    if (!room.cards || room.cards.length === 0) {
        room.cards = [];
        for (let i = 1; i <= 100; i++) {
            room.cards.push({ id: i, takenBy: null });
        }
    }

    // Send cards back only to requesting player
    ws.send(JSON.stringify({
        type: "room_cards",
        roomId: data.roomId,
        cards: room.cards
    }));

    break;
}

      // ----- Select card -----
case "select_card": {
  const room = rooms[data.roomId];
  if (!room) break;

  const card = room.cards.find(c => c.id === data.cardId);
  if (!card) {
    ws.send(JSON.stringify({ type: "card_rejected", reason: "Card not found" }));
    break;
  }

  // ðŸ”¹ Limit max 4 cards per user
  const userCards = room.cards.filter(c => c.takenBy === data.userId);
  if (userCards.length >= 4) {
    ws.send(JSON.stringify({ type: "card_rejected", reason: "Max 4 cards reached" }));
    break;
  }

  // ðŸ”¹ Already taken by someone else?
  if (card.takenBy) {
    ws.send(JSON.stringify({ type: "card_rejected", reason: "Already taken" }));
    break;
  }

  // ðŸ”¹ Mark the card as taken
  card.takenBy = data.userId;

  // ðŸ”¹ Confirm selection back to the player
  ws.send(JSON.stringify({
    type: "card_selected",
    roomId: data.roomId,
    cardId: card.id,
    userId: data.userId
  }));

  // ðŸ”¹ Broadcast to *all* players (including self for UI sync)
  room.players.forEach(p => {
    if (p.readyState === WebSocket.OPEN) {
      p.send(JSON.stringify({
        type: "card_taken",
        roomId: data.roomId,
      
      // ----- Claim Bingo -----
      case "claim_bingo": {
        const room = rooms[data.roomId];
        if (!room) return;

        const player = room.players.find(p => p.id === data.playerId);
        if (!player) return  let winningCard = null;
        let winningPattern = null;

        for (const card of player.cards) {
          if (checkBingo(card, room.numbersCalled)) {
            winningCard = card;
            winningPattern = extractWinningPattern(card, room.numbersCalled);
            break;
          }
        }

        if (winningCard) {
          const jackpot = calcJackpot(room);
          await db.read();
          const user = db.data.players.find(u => u.userId === player.userId);
          if (user) {
            user.balance += jackpot;
            user.wins++;
            await db.write();
          }

          room.players.forEach(p => p.send(JSON.stringify({
            type: "bingo_win",
            winnerId: player.id,
            winnerCard,
            winningPattern
          })));

          clearInterval(room.gameInterval);
          room.gameStarted = false;
          room.players.forEach(p => p.send(JSON.stringify({ type: "game_end" })));
          room.numbersCalled = [];
          updateRoomStatus();
        } else {
          ws.send(JSON.stringify({ type: "invalid_bingo" }));
        }
        break;
      }

      // ----- Get room cards -----
      case "get_cards": {
        if (rooms[data.roomId]) {
          ws.send(JSON.stringify({ type: "room_cards", roomId: data.roomId, cards: rooms[data.roomId].cards }));
        }
        break;
      }

      // ----- Deposit / Withdrawal Requests -----
      case "request_deposit":
      case "request_withdrawal": {
        const req = {
          id: uuid(),
          userId: data.userId,
          type: data.type === "request_deposit" ? "deposit" : "withdrawal",
          amount: data.amount,
          status: "pending"
        };
        await db.read();
        db.data.requests.push(req);
        await db.write();
        ws.send(JSON.stringify({ type: "request_status_update", ...req }));
        break;
      }

      // ----- Admin Requests -----
      case "get_admin_requests": {
        await db.read();
        ws.send(JSON.stringify({ type: "requests_data", requests: db.data.requests }));
        break;
      }

      case "approve_request":
      case "reject_request": {
        await db.read();
        const req = db.data.requests.find(r => r.id === data.requestId);
        if (!req) return;
        req.status = data.type === "approve_request" ? "approved" : "rejected";

        if (req.status === "approved") {
          const user = db.data.players.find(u => u.userId === req.userId);
          if (user) {
            if (req.type === "deposit") user.balance += req.amount;
            else if (req.type === "withdrawal") user.balance -= req.amount;
            await db.write();
          }
        }
        await db.write();
        ws.send(JSON.stringify({ type: "request_action_success" }));
        break;
      }
    }
  });

  // ----- Handle disconnect -----
  ws.on("close", () => {
    const player = players.get(ws);
    if (player && player.roomId) {
      const room = rooms[player.roomId];
      room.players = room.players.filter(p => p.id !== ws.id);
      updateRoomStatus();
    }
    players.delete(ws);
  });
});

// ----- Serve frontend -----
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "index.html"));
});

// ----- Start server -----
(async () => {
  await initDB();
  await loadRooms();
  const PORT = process.env.PORT || 3000;
  server.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));
})();
